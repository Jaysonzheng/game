%% Author: xiaoshengaya
%% Created: 2010-2-2
%% Description: 
-module(socket_handler).

-behaviour(gen_fsm).

-include("protocol.hrl").

-export([start_link/1, set_socket/3, send_data/2]).

%% gen_fsm callbacks
-export([init/1, handle_event/3,
         handle_sync_event/4, handle_info/3, terminate/3, code_change/4]).

%% FSM States
-export([
    'WAIT_FOR_SOCKET'/2,
    'WAIT_FOR_DATA'/2,
    'WAIT_FOR_ECHO'/2
]).

%% 解析数据包相关数据结构
-record(packet, {
				buffer = [],	%% buffer
				bodylength = 0,	%% 包长
				readpos = 0		%% 当前读的位置				
				}).

-record(state, {
				connid,		% connection id
                socket,		% client socket
                addr,   	% client address
			   	server,
 				packet = #packet{}	% socket buffer
               }).

-define(TIMEOUT, 300000).		%% 5  minutes
-define(WAIT_ECHO_TIME, 30000).	%% 30 seconds

%%%------------------------------------------------------------------------
%%% API
%%%------------------------------------------------------------------------

%%-------------------------------------------------------------------------
%% @spec (Socket) -> {ok,Pid} | ignore | {error,Error}
%% @doc To be called by the supervisor in order to start the server.
%%      If init/1 fails with Reason, the function returns {error,Reason}.
%%      If init/1 returns {stop,Reason} or ignore, the process is
%%      terminated and the function returns {error,Reason} or ignore,
%%      respectively.
%% @end
%%-------------------------------------------------------------------------
start_link(Server) ->
    gen_fsm:start_link(?MODULE, [Server], []).

set_socket(Pid, Socket, SocketId) when is_pid(Pid), is_port(Socket), is_integer(SocketId) ->
    gen_fsm:send_event(Pid, {socket_ready, Socket, SocketId}).

%%%------------------------------------------------------------------------
%%% Callback functions from gen_server
%%%------------------------------------------------------------------------

%%-------------------------------------------------------------------------
%% Func: init/1
%% Returns: {ok, StateName, StateData}          |
%%          {ok, StateName, StateData, Timeout} |
%%          ignore                              |
%%          {stop, StopReason}
%% @private
%%-------------------------------------------------------------------------
init([Server]) ->
    process_flag(trap_exit, true),
	{ok, 'WAIT_FOR_SOCKET', #state{server = Server}}.

%%-------------------------------------------------------------------------
%% Func: StateName/2
%% Returns: {next_state, NextStateName, NextStateData}          |
%%          {next_state, NextStateName, NextStateData, Timeout} |
%%          {stop, Reason, NewStateData}
%% @private
%%-------------------------------------------------------------------------
'WAIT_FOR_SOCKET'({socket_ready, Socket, ConnId}, #state{server = Server} = State) 
  when is_port(Socket), is_integer(ConnId) ->
    % Now we own the socket
    inet:setopts(Socket, [{active, once}, binary]),
	Server:handle_accept(Socket),
	{ok, {IP, _Port}} = inet:peername(Socket),
    {next_state, 'WAIT_FOR_DATA', State#state{connid=ConnId, socket=Socket, addr=IP}, ?TIMEOUT};

'WAIT_FOR_SOCKET'(Other, State) ->
    error_logger:error_msg("State: 'WAIT_FOR_SOCKET'. Unexpected message: ~p\n", [Other]),
    %% Allow to receive async messages
    {next_state, 'WAIT_FOR_SOCKET', State}.

%% Notification event coming from client
'WAIT_FOR_DATA'({data, Data}, State) ->
	recv_data({data, Data}, State);

'WAIT_FOR_DATA'(timeout, #state{socket=Socket} = State) ->
%%	io:format("~p Client connection timeout - sending sync,waiting for echo.\n", [self()]),
%%  {stop, normal, State};
	SyncPacket = protocol:build_packet(?SERVER_CMD_SYNC),
	catch gen_tcp:send(Socket, SyncPacket),
    {next_state, 'WAIT_FOR_ECHO', State, ?WAIT_ECHO_TIME};

'WAIT_FOR_DATA'(_Data, State) ->
%%  io:format("~p Ignoring data: ~p\n", [self(), Data]),
    {next_state, 'WAIT_FOR_DATA', State, ?TIMEOUT}.

'WAIT_FOR_ECHO'({data, Data}, State) ->
	recv_data({data, Data}, State);
			
'WAIT_FOR_ECHO'(timeout, State) ->
%%  error_logger:error_msg("~p Client connection timeout - closing.\n", [self()]),
    {stop, normal, State}.

%%-------------------------------------------------------------------------
%% Func: handle_event/3
%% Returns: {next_state, NextStateName, NextStateData}          |
%%          {next_state, NextStateName, NextStateData, Timeout} |
%%          {stop, Reason, NewStateData}
%% @private
%%-------------------------------------------------------------------------
handle_event(Event, StateName, StateData) ->
    {stop, {StateName, undefined_event, Event}, StateData}.

%%-------------------------------------------------------------------------
%% Func: handle_sync_event/4
%% Returns: {next_state, NextStateName, NextStateData}            |
%%          {next_state, NextStateName, NextStateData, Timeout}   |
%%          {reply, Reply, NextStateName, NextStateData}          |
%%          {reply, Reply, NextStateName, NextStateData, Timeout} |
%%          {stop, Reason, NewStateData}                          |
%%          {stop, Reason, Reply, NewStateData}
%% @private
%%-------------------------------------------------------------------------
handle_sync_event(Event, _From, StateName, StateData) ->
    {stop, {StateName, undefined_event, Event}, StateData}.

%%-------------------------------------------------------------------------
%% Func: handle_info/3
%% Returns: {next_state, NextStateName, NextStateData}          |
%%          {next_state, NextStateName, NextStateData, Timeout} |
%%          {stop, Reason, NewStateData}
%% @private
%%-------------------------------------------------------------------------
handle_info({tcp, Socket, Bin}, StateName, #state{socket=Socket} = StateData) ->
    % Flow control: enable forwarding of next TCP message
    inet:setopts(Socket, [{active, once}]),
    ?MODULE:StateName({data, Bin}, StateData);

handle_info({tcp_closed, Socket}, _StateName,
            #state{socket=Socket, addr=_Addr} = StateData) ->
%%     io:format("~p Client ~p disconnected.\n", [self(), Addr]),
    {stop, normal, StateData};

handle_info(_Info, _StateName, StateData) ->
    {stop, normal, StateData}.

%%-------------------------------------------------------------------------
%% Func: terminate/3
%% Purpose: Shutdown the fsm
%% Returns: any
%% @private
%%-------------------------------------------------------------------------
terminate(_Reason, _StateName, #state{connid=ConnId, socket=Socket, server=Server}) ->
    Server:handle_close(Socket),
	(catch gen_tcp:close(Socket)),
    ok.

%%-------------------------------------------------------------------------
%% Func: code_change/4
%% Purpose: Convert process state when code is changed
%% Returns: {ok, NewState, NewStateData}
%% @private
%%-------------------------------------------------------------------------
code_change(_OldVsn, StateName, StateData, _Extra) ->
    {ok, StateName, StateData}.

recv_data({data, Data}, #state{socket=Socket, server = Server, packet = Packet} = State) when is_binary(Data) ->
	L = binary_to_list(Data),
 	io:format("++++++++recv_data = ~s~n", [Data]),
	case parse(Packet, L) of
		{websocket} ->
       Handshake =
              [
                      "HTTP/1.1 101 Web Socket Protocol Handshake\r\n",
                      "Upgrade: WebSocket\r\n",
                      "Connection: Upgrade\r\n",
                      "Sec-WebSocket-Origin:192.168.100.30\r\n",
                      "Sec-WebSocket-Location: ",
                      "  ws://192.168.100.30:443/hello\r\n\r\n"
              ],
             gen_tcp:send(Socket, Handshake),
			%%send_data(Socket, list_to_binary("HTTP/1.1 101 WebSocket Protocol Handshake\r\nUpgrade: WebSocket\r\nSec-WebSocket-Accept: me89jWimTRKTWwrS3aRrL53YZSo=\r\nConnection: Upgrade\r\nSec-WebSocket-Origin:192.168.100.30\r\nSec-WebSocket-Location: ws://192.168.100.38:8888/\r\n\r\n")),
			NewState = State#state{packet = null},
			{next_state, 'WAIT_FOR_DATA', NewState, ?TIMEOUT};			
			%%{stop, normal, State};
			
		{policy_request} ->
			send_data(Socket, list_to_binary("<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"*\" /></cross-domain-policy>\0")),
			{stop, normal, State};
		{complete, Bin, RestPacket} ->
%% 			io:format("++++++complete Bin= ~p, RestPacket~p~n", [Bin, RestPacket]),
			NewState = State#state{packet = RestPacket},
			case protocol:get_cmd_type(Bin) of
				{ok, ?CLIENT_CMD_SYNC} ->
					recv_data({data, []}, NewState);
				_ ->
					case Server:handle_read(Socket, Bin) of
						ok-> recv_data({data, []}, NewState);
						_ -> {stop, normal, State}
					end
			end;
		{needmore, RestPacket} ->
			NewState = State#state{packet = RestPacket},
			{next_state, 'WAIT_FOR_DATA', NewState, ?TIMEOUT}			
	end;

recv_data({data, Data}, #state{socket=Socket, server = Server, packet = Packet} = State) when is_list(Data) ->
	#packet{buffer = L} = Packet,
%% 	io:format("---====recv_data = ~p, L:~p~n", [Data, L]),
	case L of
	[] ->
%% 		io:format("wait for data~n"),
		{next_state, 'WAIT_FOR_DATA', State, ?TIMEOUT};	   
	_ ->
	case parse(Packet, L) of
		{complete, Bin, RestPacket} ->
%% 			io:format("-------complete Bin2= ~p~n", [Bin]),
			NewState = State#state{packet = RestPacket},
%% 			recv_data({data, []}, NewState);
			case protocol:get_cmd_type(Bin) of
				{ok, ?CLIENT_CMD_SYNC} ->
					recv_data({data, []}, NewState);
				_ ->
					case Server:handle_read(Socket, Bin) of
						ok-> recv_data({data, []}, NewState);
						_ -> {stop, normal, State}
				end
			end;
		{needmore, RestPacket} ->
			NewState = State#state{packet = RestPacket},
			{next_state, 'WAIT_FOR_DATA', NewState, ?TIMEOUT}
	end
	end.

send_data(Socket, Packet) ->
%%	gen_tcp:send(Sock, Packet).
	case catch gen_tcp:send(Socket, Packet) of
        ok ->
            ok;
        {error, closed} ->
            ok;
        {error,econnaborted} ->
            ok;
        Any ->
            error_logger:error_report([
                                       {message, "gen_tcp:send error"},
                                       {module, ?MODULE},
                                       {line, ?LINE},
                                       {socket, Socket},
                                       {port_info, erlang:port_info(Socket, connected)},
                                       {bin, Packet},
                                       {error, Any}
                                      ])
    end.

parse(_Packet, "GET"++_Rest) -> io:format("websocket get "),{websocket};
parse(_Pakcet, "<policy-file-request/>\0") -> {policy_request};	%% 策略文件请求
parse(Packet, L) ->
	#packet{bodylength = BodyLen, readpos = ReadPos} = Packet,
%% 	NewBuffer = Buffer ++ L,
	read(L, [], BodyLen, ReadPos).

read(Buffer, [], 0, 0)->				%% 解析包长
	{BodyLenList, Rest} = lists:split(2, Buffer),
	<<BodyLen:?SHORT>> = list_to_binary(BodyLenList),
%% 	io:format("Body length = ~p~n", [BodyLen]),
	read(Rest, [], BodyLen, 0);

read([H|T], L, BodyLen, ReadPos) when BodyLen /= ReadPos->
%% 	io:format("ReadPos:~p, H:~p, T:~p~n", [ReadPos, H, T]),
	read(T, [H|L], BodyLen, ReadPos+1);

read(T, L, BodyLen, BodyLen) ->	
	L2 = lists:reverse(L),
	Bin = list_to_binary(L2),
%% 	T2 = lists:split(BodyLen, T),
%% 	io:format("ReadPos:~p, BodyLen~p~n", [BodyLen, BodyLen]),
	{complete, Bin, #packet{buffer = T}};

read([], L, BodyLen, ReadPos) -> 
	{needmore, #packet{buffer = L, bodylength = BodyLen, readpos = ReadPos}}.
